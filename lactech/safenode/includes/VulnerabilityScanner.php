<?php
/**
 * SafeNode - Vulnerability Scanner
 * Scanner automático de vulnerabilidades
 * 
 * Verifica:
 * - Dependências desatualizadas (Composer)
 * - Versões de PHP
 * - Padrões inseguros em código
 */

class VulnerabilityScanner {
    private $db;
    private $projectPath;
    
    public function __construct($database, $projectPath = null) {
        $this->db = $database;
        $this->projectPath = $projectPath ?: dirname(dirname(__DIR__));
    }
    
    /**
     * Executa scan completo de vulnerabilidades
     * 
     * @return array Resultado do scan
     */
    public function scan() {
        $results = [
            'dependencies' => $this->scanDependencies(),
            'php_version' => $this->checkPHPVersion(),
            'code_patterns' => $this->scanCodePatterns(),
            'file_permissions' => $this->checkFilePermissions(),
            'timestamp' => date('c')
        ];
        
        // Calcular score geral
        $results['overall_score'] = $this->calculateOverallScore($results);
        
        // Salvar resultado
        $this->saveScanResult($results);
        
        return $results;
    }
    
    /**
     * Escaneia dependências do Composer
     */
    private function scanDependencies() {
        $composerFile = $this->projectPath . '/composer.json';
        $composerLock = $this->projectPath . '/composer.lock';
        
        if (!file_exists($composerFile)) {
            return ['status' => 'no_composer', 'vulnerabilities' => []];
        }
        
        $vulnerabilities = [];
        
        // Ler composer.lock se existir
        if (file_exists($composerLock)) {
            $lockData = json_decode(file_get_contents($composerLock), true);
            
            if (isset($lockData['packages'])) {
                foreach ($lockData['packages'] as $package) {
                    $name = $package['name'] ?? '';
                    $version = $package['version'] ?? '';
                    
                    // Verificar versões muito antigas (simplificado)
                    // Em produção, integrar com Snyk ou OWASP Dependency-Check
                    if ($this->isVulnerableVersion($name, $version)) {
                        $vulnerabilities[] = [
                            'package' => $name,
                            'version' => $version,
                            'severity' => 'medium',
                            'description' => "Versão $version pode conter vulnerabilidades conhecidas"
                        ];
                    }
                }
            }
        }
        
        return [
            'status' => 'scanned',
            'total_packages' => count($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Verifica se versão é vulnerável (simplificado)
     */
    private function isVulnerableVersion($package, $version) {
        // Lista de pacotes conhecidos com versões vulneráveis
        // Em produção, usar API de vulnerabilidades (Snyk, etc)
        $vulnerablePackages = [
            'monolog/monolog' => ['<1.25.0'],
            'guzzlehttp/guzzle' => ['<6.5.0', '<7.0.0']
        ];
        
        if (!isset($vulnerablePackages[$package])) {
            return false;
        }
        
        // Verificação simplificada
        foreach ($vulnerablePackages[$package] as $vulnVersion) {
            if (version_compare($version, $vulnVersion, '<')) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Verifica versão do PHP
     */
    private function checkPHPVersion() {
        $phpVersion = PHP_VERSION;
        $minVersion = '8.0.0';
        $recommendedVersion = '8.1.0';
        
        $isSecure = version_compare($phpVersion, $minVersion, '>=');
        $isRecommended = version_compare($phpVersion, $recommendedVersion, '>=');
        
        // Verificar se há vulnerabilidades conhecidas na versão
        $knownVulnerabilities = $this->checkPHPVulnerabilities($phpVersion);
        
        return [
            'current_version' => $phpVersion,
            'is_secure' => $isSecure,
            'is_recommended' => $isRecommended,
            'min_version' => $minVersion,
            'recommended_version' => $recommendedVersion,
            'vulnerabilities' => $knownVulnerabilities
        ];
    }
    
    /**
     * Verifica vulnerabilidades conhecidas do PHP
     */
    private function checkPHPVulnerabilities($version) {
        // Em produção, consultar CVE database
        // Por enquanto, verificação básica
        $vulnerabilities = [];
        
        // PHP < 8.0 tem vulnerabilidades conhecidas
        if (version_compare($version, '8.0.0', '<')) {
            $vulnerabilities[] = [
                'severity' => 'high',
                'description' => 'PHP < 8.0 contém vulnerabilidades conhecidas. Atualize para PHP 8.0+'
            ];
        }
        
        return $vulnerabilities;
    }
    
    /**
     * Escaneia código por padrões inseguros
     */
    private function scanCodePatterns() {
        $vulnerabilities = [];
        $phpFiles = $this->getPHPFiles();
        
        $insecurePatterns = [
            [
                'pattern' => '/eval\s*\(/i',
                'severity' => 'critical',
                'description' => 'Uso de eval() é perigoso'
            ],
            [
                'pattern' => '/exec\s*\(/i',
                'severity' => 'high',
                'description' => 'Uso de exec() pode ser inseguro'
            ],
            [
                'pattern' => '/system\s*\(/i',
                'severity' => 'high',
                'description' => 'Uso de system() pode ser inseguro'
            ],
            [
                'pattern' => '/shell_exec\s*\(/i',
                'severity' => 'high',
                'description' => 'Uso de shell_exec() pode ser inseguro'
            ],
            [
                'pattern' => '/\$_(GET|POST|REQUEST)\[.*\]\s*\)/i',
                'severity' => 'medium',
                'description' => 'Uso direto de $_GET/$_POST sem sanitização'
            ],
            [
                'pattern' => '/mysql_query\s*\(/i',
                'severity' => 'high',
                'description' => 'mysql_query() está deprecado, use PDO'
            ],
            [
                'pattern' => '/password\s*=\s*["\']([^"\']+)["\']/i',
                'severity' => 'critical',
                'description' => 'Senha hardcoded no código'
            ]
        ];
        
        foreach ($phpFiles as $file) {
            $content = file_get_contents($file);
            
            foreach ($insecurePatterns as $patternData) {
                if (preg_match($patternData['pattern'], $content, $matches)) {
                    $vulnerabilities[] = [
                        'file' => str_replace($this->projectPath, '', $file),
                        'pattern' => $patternData['pattern'],
                        'severity' => $patternData['severity'],
                        'description' => $patternData['description'],
                        'line' => $this->getLineNumber($file, $matches[0])
                    ];
                }
            }
        }
        
        return [
            'files_scanned' => count($phpFiles),
            'vulnerabilities_found' => count($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Obtém arquivos PHP do projeto
     */
    private function getPHPFiles($dir = null, $files = []) {
        $dir = $dir ?: $this->projectPath;
        
        $items = scandir($dir);
        foreach ($items as $item) {
            if ($item === '.' || $item === '..' || $item === 'vendor' || $item === 'node_modules') {
                continue;
            }
            
            $path = $dir . '/' . $item;
            
            if (is_dir($path)) {
                $files = $this->getPHPFiles($path, $files);
            } elseif (pathinfo($path, PATHINFO_EXTENSION) === 'php') {
                $files[] = $path;
            }
        }
        
        return $files;
    }
    
    /**
     * Obtém número da linha onde padrão foi encontrado
     */
    private function getLineNumber($file, $pattern) {
        $lines = file($file);
        foreach ($lines as $num => $line) {
            if (strpos($line, $pattern) !== false) {
                return $num + 1;
            }
        }
        return null;
    }
    
    /**
     * Verifica permissões de arquivos
     */
    private function checkFilePermissions() {
        $issues = [];
        
        $sensitiveFiles = [
            '.env',
            'config.php',
            'composer.json',
            'composer.lock'
        ];
        
        foreach ($sensitiveFiles as $file) {
            $filepath = $this->projectPath . '/' . $file;
            if (file_exists($filepath)) {
                $perms = fileperms($filepath);
                $octal = substr(sprintf('%o', $perms), -4);
                
                // Arquivos sensíveis não devem ser acessíveis publicamente
                if ($octal[2] > 4 || $octal[3] > 4) {
                    $issues[] = [
                        'file' => $file,
                        'permissions' => $octal,
                        'severity' => 'high',
                        'description' => "Arquivo $file tem permissões muito abertas ($octal)"
                    ];
                }
            }
        }
        
        return [
            'files_checked' => count($sensitiveFiles),
            'issues' => $issues
        ];
    }
    
    /**
     * Calcula score geral de segurança
     */
    private function calculateOverallScore($results) {
        $score = 100;
        
        // Penalizar por vulnerabilidades
        if (isset($results['dependencies']['vulnerabilities'])) {
            $score -= count($results['dependencies']['vulnerabilities']) * 5;
        }
        
        if (isset($results['php_version']['vulnerabilities'])) {
            $score -= count($results['php_version']['vulnerabilities']) * 10;
        }
        
        if (isset($results['code_patterns']['vulnerabilities'])) {
            foreach ($results['code_patterns']['vulnerabilities'] as $vuln) {
                $penalty = $vuln['severity'] === 'critical' ? 15 : ($vuln['severity'] === 'high' ? 10 : 5);
                $score -= $penalty;
            }
        }
        
        if (isset($results['file_permissions']['issues'])) {
            $score -= count($results['file_permissions']['issues']) * 5;
        }
        
        return max(0, min(100, $score));
    }
    
    /**
     * Salva resultado do scan
     */
    private function saveScanResult($results) {
        if (!$this->db) return;
        
        try {
            $this->ensureTableExists();
            
            $stmt = $this->db->prepare("
                INSERT INTO safenode_vulnerability_scans 
                (scan_data, overall_score, created_at) 
                VALUES (?, ?, NOW())
            ");
            
            $stmt->execute([
                json_encode($results),
                $results['overall_score']
            ]);
        } catch (PDOException $e) {
            error_log("SafeNode VulnerabilityScanner Save Error: " . $e->getMessage());
        }
    }
    
    /**
     * Garante que tabela existe
     */
    private function ensureTableExists() {
        try {
            $this->db->query("SELECT 1 FROM safenode_vulnerability_scans LIMIT 1");
        } catch (PDOException $e) {
            $this->db->exec("
                CREATE TABLE IF NOT EXISTS safenode_vulnerability_scans (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    scan_data JSON,
                    overall_score INT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    INDEX idx_score (overall_score),
                    INDEX idx_created (created_at)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            ");
        }
    }
}






