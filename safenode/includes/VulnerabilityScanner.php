<?php
/**
 * SafeNode - Vulnerability Scanner
 * Scanner automático de vulnerabilidades
 * 
 * Verifica:
 * - Dependências desatualizadas (Composer)
 * - Versões de PHP
 * - Padrões inseguros em código
 */

class VulnerabilityScanner {
    private $db;
    private $projectPath;
    
    public function __construct($database, $projectPath = null) {
        $this->db = $database;
        $this->projectPath = $projectPath ?: dirname(dirname(__DIR__));
    }
    
    /**
     * Executa scan completo de vulnerabilidades
     * 
     * @param int $siteId ID do site a ser escaneado
     * @return array Resultado do scan
     */
    public function scan($siteId = null) {
        $results = [
            'dependencies' => $this->scanDependencies(),
            'php_version' => $this->checkPHPVersion(),
            'code_patterns' => $this->scanCodePatterns(),
            'file_permissions' => $this->checkFilePermissions(),
            'security_headers' => $this->checkSecurityHeaders($siteId),
            'server_config' => $this->checkServerConfig(),
            'exposed_info' => $this->checkExposedInformation(),
            'timestamp' => date('c'),
            'site_id' => $siteId
        ];
        
        // Calcular score geral
        $results['overall_score'] = $this->calculateOverallScore($results);
        
        // Salvar resultado
        $this->saveScanResult($results, $siteId);
        
        return $results;
    }
    
    /**
     * Escaneia dependências do Composer
     */
    private function scanDependencies() {
        $composerFile = $this->projectPath . '/composer.json';
        $composerLock = $this->projectPath . '/composer.lock';
        
        if (!file_exists($composerFile)) {
            return ['status' => 'no_composer', 'vulnerabilities' => []];
        }
        
        $vulnerabilities = [];
        
        // Ler composer.lock se existir
        if (file_exists($composerLock)) {
            $lockData = json_decode(file_get_contents($composerLock), true);
            
            if (isset($lockData['packages'])) {
                foreach ($lockData['packages'] as $package) {
                    $name = $package['name'] ?? '';
                    $version = $package['version'] ?? '';
                    
                    // Verificar versões muito antigas (simplificado)
                    // Em produção, integrar com Snyk ou OWASP Dependency-Check
                    if ($this->isVulnerableVersion($name, $version)) {
                        $vulnerabilities[] = [
                            'package' => $name,
                            'version' => $version,
                            'severity' => 'medium',
                            'description' => "Versão $version pode conter vulnerabilidades conhecidas"
                        ];
                    }
                }
            }
        }
        
        return [
            'status' => 'scanned',
            'total_packages' => count($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Verifica se versão é vulnerável (simplificado)
     */
    private function isVulnerableVersion($package, $version) {
        // Lista de pacotes conhecidos com versões vulneráveis
        // Em produção, usar API de vulnerabilidades (Snyk, etc)
        $vulnerablePackages = [
            'monolog/monolog' => ['<1.25.0'],
            'guzzlehttp/guzzle' => ['<6.5.0', '<7.0.0']
        ];
        
        if (!isset($vulnerablePackages[$package])) {
            return false;
        }
        
        // Verificação simplificada
        foreach ($vulnerablePackages[$package] as $vulnVersion) {
            if (version_compare($version, $vulnVersion, '<')) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Verifica versão do PHP
     */
    private function checkPHPVersion() {
        $phpVersion = PHP_VERSION;
        $minVersion = '8.0.0';
        $recommendedVersion = '8.1.0';
        
        $isSecure = version_compare($phpVersion, $minVersion, '>=');
        $isRecommended = version_compare($phpVersion, $recommendedVersion, '>=');
        
        // Verificar se há vulnerabilidades conhecidas na versão
        $knownVulnerabilities = $this->checkPHPVulnerabilities($phpVersion);
        
        return [
            'current_version' => $phpVersion,
            'is_secure' => $isSecure,
            'is_recommended' => $isRecommended,
            'min_version' => $minVersion,
            'recommended_version' => $recommendedVersion,
            'vulnerabilities' => $knownVulnerabilities
        ];
    }
    
    /**
     * Verifica vulnerabilidades conhecidas do PHP
     */
    private function checkPHPVulnerabilities($version) {
        // Em produção, consultar CVE database
        // Por enquanto, verificação básica
        $vulnerabilities = [];
        
        // PHP < 8.0 tem vulnerabilidades conhecidas
        if (version_compare($version, '8.0.0', '<')) {
            $vulnerabilities[] = [
                'severity' => 'high',
                'description' => 'PHP < 8.0 contém vulnerabilidades conhecidas. Atualize para PHP 8.0+'
            ];
        }
        
        return $vulnerabilities;
    }
    
    /**
     * Escaneia código por padrões inseguros
     */
    private function scanCodePatterns() {
        $vulnerabilities = [];
        $phpFiles = $this->getPHPFiles();
        
        $insecurePatterns = [
            [
                'pattern' => '/eval\s*\(/i',
                'severity' => 'critical',
                'description' => 'Uso de eval() é perigoso'
            ],
            [
                'pattern' => '/exec\s*\(/i',
                'severity' => 'high',
                'description' => 'Uso de exec() pode ser inseguro'
            ],
            [
                'pattern' => '/system\s*\(/i',
                'severity' => 'high',
                'description' => 'Uso de system() pode ser inseguro'
            ],
            [
                'pattern' => '/shell_exec\s*\(/i',
                'severity' => 'high',
                'description' => 'Uso de shell_exec() pode ser inseguro'
            ],
            [
                'pattern' => '/\$_(GET|POST|REQUEST)\[.*\]\s*\)/i',
                'severity' => 'medium',
                'description' => 'Uso direto de $_GET/$_POST sem sanitização'
            ],
            [
                'pattern' => '/mysql_query\s*\(/i',
                'severity' => 'high',
                'description' => 'mysql_query() está deprecado, use PDO'
            ],
            [
                'pattern' => '/password\s*=\s*["\']([^"\']+)["\']/i',
                'severity' => 'critical',
                'description' => 'Senha hardcoded no código'
            ]
        ];
        
        foreach ($phpFiles as $file) {
            $content = file_get_contents($file);
            
            foreach ($insecurePatterns as $patternData) {
                if (preg_match($patternData['pattern'], $content, $matches)) {
                    $vulnerabilities[] = [
                        'file' => str_replace($this->projectPath, '', $file),
                        'pattern' => $patternData['pattern'],
                        'severity' => $patternData['severity'],
                        'description' => $patternData['description'],
                        'line' => $this->getLineNumber($file, $matches[0])
                    ];
                }
            }
        }
        
        return [
            'files_scanned' => count($phpFiles),
            'vulnerabilities_found' => count($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Obtém arquivos PHP do projeto
     */
    private function getPHPFiles($dir = null, $files = []) {
        $dir = $dir ?: $this->projectPath;
        
        $items = scandir($dir);
        foreach ($items as $item) {
            if ($item === '.' || $item === '..' || $item === 'vendor' || $item === 'node_modules') {
                continue;
            }
            
            $path = $dir . '/' . $item;
            
            if (is_dir($path)) {
                $files = $this->getPHPFiles($path, $files);
            } elseif (pathinfo($path, PATHINFO_EXTENSION) === 'php') {
                $files[] = $path;
            }
        }
        
        return $files;
    }
    
    /**
     * Obtém número da linha onde padrão foi encontrado
     */
    private function getLineNumber($file, $pattern) {
        $lines = file($file);
        foreach ($lines as $num => $line) {
            if (strpos($line, $pattern) !== false) {
                return $num + 1;
            }
        }
        return null;
    }
    
    /**
     * Verifica permissões de arquivos
     */
    private function checkFilePermissions() {
        $issues = [];
        
        $sensitiveFiles = [
            '.env',
            'config.php',
            'composer.json',
            'composer.lock'
        ];
        
        foreach ($sensitiveFiles as $file) {
            $filepath = $this->projectPath . '/' . $file;
            if (file_exists($filepath)) {
                $perms = fileperms($filepath);
                $octal = substr(sprintf('%o', $perms), -4);
                
                // Arquivos sensíveis não devem ser acessíveis publicamente
                if ($octal[2] > 4 || $octal[3] > 4) {
                    $issues[] = [
                        'file' => $file,
                        'permissions' => $octal,
                        'severity' => 'high',
                        'description' => "Arquivo $file tem permissões muito abertas ($octal)"
                    ];
                }
            }
        }
        
        return [
            'files_checked' => count($sensitiveFiles),
            'issues' => $issues
        ];
    }
    
    /**
     * Calcula score geral de segurança
     */
    private function calculateOverallScore($results) {
        $score = 100;
        
        // Penalizar por vulnerabilidades
        if (isset($results['dependencies']['vulnerabilities'])) {
            $score -= count($results['dependencies']['vulnerabilities']) * 5;
        }
        
        if (isset($results['php_version']['vulnerabilities'])) {
            $score -= count($results['php_version']['vulnerabilities']) * 10;
        }
        
        if (isset($results['code_patterns']['vulnerabilities'])) {
            foreach ($results['code_patterns']['vulnerabilities'] as $vuln) {
                $penalty = $vuln['severity'] === 'critical' ? 15 : ($vuln['severity'] === 'high' ? 10 : 5);
                $score -= $penalty;
            }
        }
        
        if (isset($results['file_permissions']['issues'])) {
            $score -= count($results['file_permissions']['issues']) * 5;
        }
        
        if (isset($results['security_headers']['issues'])) {
            foreach ($results['security_headers']['issues'] as $issue) {
                $penalty = $issue['severity'] === 'high' ? 8 : ($issue['severity'] === 'medium' ? 5 : 3);
                $score -= $penalty;
            }
        }
        
        if (isset($results['server_config']['issues'])) {
            foreach ($results['server_config']['issues'] as $issue) {
                $penalty = $issue['severity'] === 'high' ? 10 : ($issue['severity'] === 'medium' ? 5 : 3);
                $score -= $penalty;
            }
        }
        
        if (isset($results['exposed_info']['issues'])) {
            foreach ($results['exposed_info']['issues'] as $issue) {
                $penalty = $issue['severity'] === 'high' ? 12 : ($issue['severity'] === 'medium' ? 7 : 4);
                $score -= $penalty;
            }
        }
        
        return max(0, min(100, $score));
    }
    
    /**
     * Obtém histórico de scans
     */
    public function getScanHistory($siteId = null, $limit = 10) {
        if (!$this->db) return [];
        
        try {
            if ($siteId) {
                $stmt = $this->db->prepare("
                    SELECT * FROM safenode_vulnerability_scans
                    WHERE site_id = ?
                    ORDER BY created_at DESC
                    LIMIT ?
                ");
                $stmt->execute([$siteId, $limit]);
            } else {
                $stmt = $this->db->prepare("
                    SELECT * FROM safenode_vulnerability_scans
                    ORDER BY created_at DESC
                    LIMIT ?
                ");
                $stmt->execute([$limit]);
            }
            
            return $stmt->fetchAll(PDO::FETCH_ASSOC);
        } catch (PDOException $e) {
            error_log("VulnerabilityScanner GetHistory Error: " . $e->getMessage());
            return [];
        }
    }
    
    /**
     * Obtém detalhes de um scan específico
     */
    public function getScanDetails($scanId) {
        if (!$this->db) return null;
        
        try {
            $stmt = $this->db->prepare("
                SELECT * FROM safenode_vulnerability_scans
                WHERE id = ?
            ");
            $stmt->execute([$scanId]);
            $scan = $stmt->fetch(PDO::FETCH_ASSOC);
            
            if ($scan) {
                $scan['scan_data'] = json_decode($scan['scan_data'], true);
            }
            
            return $scan;
        } catch (PDOException $e) {
            error_log("VulnerabilityScanner GetDetails Error: " . $e->getMessage());
            return null;
        }
    }
    
    /**
     * Verifica headers de segurança
     */
    private function checkSecurityHeaders($siteId) {
        $issues = [];
        $headers = [];
        
        if ($siteId && $this->db) {
            try {
                $stmt = $this->db->prepare("SELECT domain FROM safenode_sites WHERE id = ?");
                $stmt->execute([$siteId]);
                $site = $stmt->fetch(PDO::FETCH_ASSOC);
                
                if ($site && !empty($site['domain'])) {
                    $url = (strpos($site['domain'], 'http') === 0 ? $site['domain'] : 'https://' . $site['domain']);
                    $headers = $this->fetchHeaders($url);
                }
            } catch (PDOException $e) {
                error_log("VulnerabilityScanner: Error fetching site: " . $e->getMessage());
            }
        }
        
        $requiredHeaders = [
            'X-Frame-Options' => 'high',
            'X-Content-Type-Options' => 'medium',
            'Strict-Transport-Security' => 'high',
            'Content-Security-Policy' => 'medium'
        ];
        
        foreach ($requiredHeaders as $header => $severity) {
            if (!isset($headers[$header]) || empty($headers[$header])) {
                $issues[] = [
                    'header' => $header,
                    'severity' => $severity,
                    'description' => "Header de segurança $header não configurado"
                ];
            }
        }
        
        return [
            'headers_checked' => count($requiredHeaders),
            'missing_headers' => count($issues),
            'issues' => $issues
        ];
    }
    
    /**
     * Faz requisição HTTP para obter headers
     */
    private function fetchHeaders($url) {
        $headers = [];
        
        if (!function_exists('curl_init')) {
            return $headers;
        }
        
        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_HEADER => true,
            CURLOPT_NOBODY => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_MAXREDIRS => 3,
            CURLOPT_TIMEOUT => 10,
            CURLOPT_SSL_VERIFYPEER => false,
            CURLOPT_USERAGENT => 'SafeNode-VulnerabilityScanner/1.0'
        ]);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        
        if ($httpCode >= 200 && $httpCode < 400 && $response) {
            $headerLines = explode("\r\n", $response);
            foreach ($headerLines as $line) {
                if (strpos($line, ':') !== false) {
                    list($key, $value) = explode(':', $line, 2);
                    $key = trim($key);
                    $value = trim($value);
                    $normalizedKey = str_replace(' ', '-', ucwords(str_replace('-', ' ', strtolower($key))));
                    $headers[$normalizedKey] = $value;
                }
            }
        }
        
        return $headers;
    }
    
    /**
     * Verifica configurações do servidor
     */
    private function checkServerConfig() {
        $issues = [];
        
        // Verificar display_errors
        if (ini_get('display_errors')) {
            $issues[] = [
                'setting' => 'display_errors',
                'severity' => 'medium',
                'description' => 'display_errors está habilitado, pode expor informações sensíveis'
            ];
        }
        
        // Verificar expose_php
        if (ini_get('expose_php')) {
            $issues[] = [
                'setting' => 'expose_php',
                'severity' => 'low',
                'description' => 'expose_php está habilitado, expõe versão do PHP'
            ];
        }
        
        // Verificar allow_url_fopen
        if (ini_get('allow_url_fopen')) {
            $issues[] = [
                'setting' => 'allow_url_fopen',
                'severity' => 'medium',
                'description' => 'allow_url_fopen está habilitado, pode ser usado para SSRF'
            ];
        }
        
        // Verificar session.cookie_httponly
        if (!ini_get('session.cookie_httponly')) {
            $issues[] = [
                'setting' => 'session.cookie_httponly',
                'severity' => 'high',
                'description' => 'session.cookie_httponly não está habilitado, vulnerável a XSS'
            ];
        }
        
        // Verificar session.cookie_secure (em produção)
        if (isset($_SERVER['HTTPS']) && !ini_get('session.cookie_secure')) {
            $issues[] = [
                'setting' => 'session.cookie_secure',
                'severity' => 'high',
                'description' => 'session.cookie_secure não está habilitado em HTTPS'
            ];
        }
        
        return [
            'settings_checked' => 5,
            'issues' => $issues
        ];
    }
    
    /**
     * Verifica exposição de informações sensíveis
     */
    private function checkExposedInformation() {
        $issues = [];
        
        // Verificar se arquivos sensíveis estão acessíveis
        $sensitivePaths = [
            '.env',
            '.git/config',
            'composer.json',
            'package.json',
            'README.md',
            'CHANGELOG.md'
        ];
        
        $webRoot = $_SERVER['DOCUMENT_ROOT'] ?? $this->projectPath;
        
        foreach ($sensitivePaths as $path) {
            $fullPath = $webRoot . '/' . $path;
            if (file_exists($fullPath)) {
                // Verificar se está acessível via web
                $url = (isset($_SERVER['HTTPS']) ? 'https://' : 'http://') . 
                       ($_SERVER['HTTP_HOST'] ?? 'localhost') . '/' . $path;
                
                if ($this->isPubliclyAccessible($url)) {
                    $issues[] = [
                        'file' => $path,
                        'severity' => 'high',
                        'description' => "Arquivo sensível $path está publicamente acessível"
                    ];
                }
            }
        }
        
        return [
            'files_checked' => count($sensitivePaths),
            'exposed_files' => count($issues),
            'issues' => $issues
        ];
    }
    
    /**
     * Verifica se URL é publicamente acessível
     */
    private function isPubliclyAccessible($url) {
        if (!function_exists('curl_init')) {
            return false;
        }
        
        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_NOBODY => true,
            CURLOPT_FOLLOWLOCATION => false,
            CURLOPT_TIMEOUT => 5,
            CURLOPT_SSL_VERIFYPEER => false,
            CURLOPT_USERAGENT => 'SafeNode-VulnerabilityScanner/1.0'
        ]);
        
        curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        
        return $httpCode >= 200 && $httpCode < 400;
    }
    
    /**
     * Salva resultado do scan
     */
    private function saveScanResult($results, $siteId = null) {
        if (!$this->db) return;
        
        try {
            $this->ensureTableExists();
            
            $stmt = $this->db->prepare("
                INSERT INTO safenode_vulnerability_scans 
                (site_id, scan_data, overall_score, created_at) 
                VALUES (?, ?, ?, NOW())
            ");
            
            $stmt->execute([
                $siteId,
                json_encode($results),
                $results['overall_score']
            ]);
            
            return $this->db->lastInsertId();
        } catch (PDOException $e) {
            error_log("SafeNode VulnerabilityScanner Save Error: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Garante que tabela existe
     */
    private function ensureTableExists() {
        try {
            $this->db->query("SELECT 1 FROM safenode_vulnerability_scans LIMIT 1");
        } catch (PDOException $e) {
            $this->db->exec("
                CREATE TABLE IF NOT EXISTS safenode_vulnerability_scans (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    site_id INT NULL,
                    scan_data JSON,
                    overall_score INT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    INDEX idx_score (overall_score),
                    INDEX idx_created (created_at),
                    INDEX idx_site (site_id),
                    FOREIGN KEY (site_id) REFERENCES safenode_sites(id) ON DELETE CASCADE
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            ");
        }
    }
}








